\documentclass[preprint,review,12pt]{elsarticle}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{siunitx}
\usepackage{subcaption}

% Theorem environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}

% Custom operators
\DeclareMathOperator{\Sym}{Sym}
\newcommand{\MDSL}{\Sigma_{\text{MDSL}}}
\newcommand{\Comp}{\mathcal{C}}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{dslstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single
}

\lstset{style=dslstyle}

\journal{Computer Physics Communications}

\begin{document}

\begin{frontmatter}

\title{MechanicsDSL: A Compiler Framework for Symbolic-Numerical Classical Mechanics Simulation}

% Author information removed for double-blind review
\author[inst1]{Anonymous Author}
\affiliation[inst1]{organization={Anonymous Institution},
            country={Anonymous}}

\begin{abstract}
We present MechanicsDSL, a domain-specific language and compiler framework that automates the complete pipeline from human-readable physics notation to optimized numerical simulation. The system accepts a LaTeX-inspired syntax for defining Lagrangian or Hamiltonian mechanical systems, automatically derives equations of motion via symbolic computation, and generates efficient numerical solvers. We introduce a formal algebraic characterization of the compilation process and a novel algorithm for robust symbolic acceleration extraction. The framework supports 17 classical mechanics domains including constraints, dissipation, and perturbation theory, along with code generation for 11 target platforms (C++, CUDA, WebAssembly, etc.). Benchmarks demonstrate that the compiled simulations match hand-optimized code performance while requiring 10-50$\times$ less development time. Validation against analytical solutions shows errors below $10^{-8}$ for standard test problems. The software is freely available under the MIT license.
\end{abstract}

\begin{keyword}
Classical mechanics \sep Domain-specific language \sep Symbolic computation \sep Numerical simulation \sep Lagrangian mechanics \sep Code generation
\end{keyword}

\end{frontmatter}

%============================================================================
\section{Introduction}
\label{sec:intro}
%============================================================================

Computational simulation of classical mechanical systems requires bridging two distinct paradigms: symbolic derivation of equations of motion and numerical integration of the resulting differential equations. This bridge is traditionally constructed manually, requiring expertise in both analytical mechanics and numerical methods---a significant barrier for physics education and rapid research prototyping.

We present MechanicsDSL, a domain-specific language (DSL) and compiler framework that automates this entire pipeline. Users specify physical systems using a LaTeX-inspired notation (Figure~\ref{fig:overview}), and the compiler automatically:
\begin{enumerate}
    \item Derives equations of motion using symbolic mathematics
    \item Generates optimized numerical solver code
    \item Produces publication-quality visualizations
\end{enumerate}

\begin{figure}[htbp]
\centering
\begin{minipage}{0.48\textwidth}
\begin{lstlisting}[caption={DSL Input}]
\system{double_pendulum}
\defvar{theta1}{Angle}{rad}
\defvar{theta2}{Angle}{rad}
\parameter{m1}{1.0}{kg}
\parameter{m2}{1.0}{kg}
\parameter{l1}{1.0}{m}
\parameter{l2}{1.0}{m}
\parameter{g}{9.81}{m/s^2}

\lagrangian{
  0.5*(m1+m2)*l1^2*\dot{theta1}^2
  + 0.5*m2*l2^2*\dot{theta2}^2
  + m2*l1*l2*\dot{theta1}*\dot{theta2}
    *cos(theta1-theta2)
  + (m1+m2)*g*l1*cos(theta1)
  + m2*g*l2*cos(theta2)
}
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\centering
\includegraphics[width=\textwidth]{fig1_double_pendulum_phase.pdf}
\end{minipage}
\caption{Overview of MechanicsDSL: A double pendulum system defined in the DSL (left) produces phase space trajectories and animations (right) without any manual equation derivation.}
\label{fig:overview}
\end{figure}

\subsection{Contributions}

This paper makes the following contributions:

\begin{enumerate}
    \item \textbf{Formal Semantics}: We introduce a compositional algebraic framework describing the DSL compilation pipeline as a chain of typed operators (Section~\ref{sec:formalism}).
    
    \item \textbf{Novel Algorithm}: We present a robust algorithm for symbolic acceleration extraction that handles edge cases in symbolic computer algebra systems (Section~\ref{sec:algorithm}).
    
    \item \textbf{Comprehensive Framework}: We describe a production-ready implementation covering 17 classical mechanics domains with code generation for 11 target platforms (Section~\ref{sec:implementation}).
    
    \item \textbf{Validation}: We provide rigorous benchmarks comparing against analytical solutions and existing tools (Section~\ref{sec:validation}).
\end{enumerate}

%============================================================================
\section{Related Work}
\label{sec:related}
%============================================================================

Several frameworks address aspects of physics simulation:

\textbf{Modelica} \cite{modelica} provides equation-based modeling for multi-domain physical systems. While powerful, it requires object-oriented syntax rather than physics-native notation and focuses on engineering systems rather than analytical mechanics.

\textbf{SymPy mechanics} \cite{sympy} offers a Python library for classical mechanics with Kane's method and Lagrangian mechanics. However, it requires Python programming expertise and manual integration with numerical solvers.

\textbf{FEniCS} \cite{fenics} targets variational problems and finite element methods, complementary to but distinct from our ODE-focused approach.

\textbf{Drake} \cite{drake} provides a C++ toolkit for robotics with rigid-body dynamics. It emphasizes control and optimization rather than physics exploration.

MechanicsDSL differs by providing:
\begin{itemize}
    \item LaTeX-inspired syntax accessible to physics students
    \item Automatic derivation from Lagrangian/Hamiltonian principles
    \item Integrated symbolic-numerical pipeline without programming
    \item Multi-target code generation from a single specification
\end{itemize}

Table~\ref{tab:comparison} summarizes the comparison.

\begin{table}[htbp]
\centering
\caption{Feature comparison with related tools}
\label{tab:comparison}
\begin{tabular}{@{}lcccccc@{}}
\toprule
Feature & \textbf{MDSL} & SymPy & Modelica & FEniCS & Drake \\
\midrule
LaTeX-like syntax     & \checkmark &          &          &          &  \\
Auto EOM derivation   & \checkmark & \checkmark &          &          & \checkmark \\
No programming req.   & \checkmark &          &          &          &  \\
Multi-target codegen  & \checkmark &          & \checkmark &          &  \\
Lagrangian mechanics  & \checkmark & \checkmark &          &          & \checkmark \\
Hamiltonian mechanics & \checkmark & \checkmark &          &          &  \\
Constraint handling   & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
Fluid dynamics (SPH)  & \checkmark &          &          & \checkmark &  \\
WebAssembly output    & \checkmark &          &          &          &  \\
\bottomrule
\end{tabular}
\end{table}

%============================================================================
\section{Formal Semantics}
\label{sec:formalism}
%============================================================================

We introduce a formal framework characterizing MechanicsDSL as a composition of well-typed operators.

\subsection{The DSL Algebra}

\begin{definition}[Syntactic Space]
The \textbf{MechanicsDSL syntactic algebra} $\MDSL$ is generated by:
\begin{equation}
\MDSL = \langle \mathcal{V}, \mathcal{P}, \mathcal{E}, \mathcal{C}, \mathcal{I} \mid R \rangle
\end{equation}
where $\mathcal{V}$ = variable declarations, $\mathcal{P}$ = parameters, $\mathcal{E}$ = energy expressions, $\mathcal{C}$ = constraints, $\mathcal{I}$ = initial conditions, and $R$ = grammar rules.
\end{definition}

\subsection{Compilation Operators}

The compilation pipeline is expressed as operator composition:
\begin{equation}
\boxed{\Comp = \mathcal{I} \circ \mathcal{N} \circ \mathcal{A} \circ \mathcal{D}_{EL} \circ \mathcal{S} \circ \mathcal{P} \circ \mathcal{L}}
\end{equation}

where:
\begin{itemize}
    \item $\mathcal{L}: \text{String} \to \mathcal{T}^*$ (lexer)
    \item $\mathcal{P}: \mathcal{T}^* \to \mathcal{A}$ (parser)
    \item $\mathcal{S}: \mathcal{A} \to \Sym(\mathbb{R})$ (symbolic mapping)
    \item $\mathcal{D}_{EL}: \Sym(\mathbb{R}) \to \Sym(\mathbb{R})^n$ (Euler-Lagrange derivation)
    \item $\mathcal{A}: \Sym(\mathbb{R})^n \to \Sym(\mathbb{R})^n$ (acceleration extraction)
    \item $\mathcal{N}: \Sym(\mathbb{R}) \to (\mathbb{R}^{2n+1} \to \mathbb{R})$ (numerical compilation)
    \item $\mathcal{I}: (\mathbb{R} \times \Gamma \to \Gamma) \to C(\mathbb{R}; \Gamma)$ (integration)
\end{itemize}

\begin{theorem}[Correctness]
For a DSL program $\sigma$ encoding physical system with Lagrangian $L$:
\begin{equation}
\|\Comp(\sigma)(t) - \mathbf{q}_{\text{exact}}(t)\| \leq \epsilon(\Delta t, \text{tol})
\end{equation}
where $\epsilon$ depends on integration step size and tolerances.
\end{theorem}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.95\textwidth]{fig3_architecture.pdf}
\caption{The MechanicsDSL compilation pipeline, showing the sequence of operators from DSL source to numerical trajectory.}
\label{fig:architecture}
\end{figure}

%============================================================================
\section{The Acceleration Extraction Algorithm}
\label{sec:algorithm}
%============================================================================

A key technical challenge is robustly solving the Euler-Lagrange equations for accelerations. Standard symbolic solvers can fail due to:
\begin{itemize}
    \item Object identity issues in derivative representations
    \item Timeout on complex simplifications
    \item Ambiguous equation structures
\end{itemize}

We present Algorithm~\ref{alg:extraction}, which uses a ``search and substitute'' approach followed by linear extraction.

\begin{algorithm}[htbp]
\caption{Robust Acceleration Extraction}
\label{alg:extraction}
\begin{algorithmic}[1]
\Require Euler-Lagrange equation $E$, coordinate $q$, acceleration symbol $\ddot{q}$
\Ensure Explicit expression for $\ddot{q}$

\State \textbf{Phase 1: Derivative Normalization}
\For{each atom $a$ in $E$}
    \If{$a$ is $\frac{d^2}{dt^2}q(t)$ (any representation)}
        \State $E \gets E[a \mapsto \ddot{q}]$ \Comment{Substitute canonical symbol}
    \EndIf
\EndFor

\State \textbf{Phase 2: Pattern Matching}
\State $q_{\text{func}} \gets q(t)$ \Comment{Time-dependent function}
\State $E \gets E\left[\frac{d^2 q_{\text{func}}}{dt^2} \mapsto \ddot{q}\right]$
\State $E \gets E\left[\frac{d q_{\text{func}}}{dt} \mapsto \dot{q}\right]$
\State $E \gets E[q_{\text{func}} \mapsto q]$

\State \textbf{Phase 3: Linear Extraction}
\State $E \gets \text{expand}(E)$
\State $M \gets \frac{\partial E}{\partial \ddot{q}}$ \Comment{Mass coefficient}
\State $B \gets E|_{\ddot{q}=0}$ \Comment{Forcing terms}

\If{$M \neq 0$}
    \State \Return $-B/M$
\Else
    \State \Return $\text{fallback\_solve}(E = 0, \ddot{q})$
\EndIf
\end{algorithmic}
\end{algorithm}

The algorithm relies on the physical guarantee that for valid Lagrangians with positive-definite kinetic energy, the mass matrix is invertible.

%============================================================================
\section{Implementation}
\label{sec:implementation}
%============================================================================

MechanicsDSL is implemented in Python ($\sim$15,000 lines) using SymPy for symbolic computation and SciPy for numerical integration.

\subsection{Classical Mechanics Domains}

The framework implements 17 specialized modules:

\begin{table}[htbp]
\centering
\caption{Implemented physics domains}
\label{tab:domains}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Category} & \textbf{Modules} \\
\midrule
Core & Lagrangian, Hamiltonian, Constraints \\
Dynamics & Rigid body (Euler angles, quaternions), Gyroscopes \\
Forces & Dissipation (Rayleigh), Friction (Coulomb, Stribeck) \\
Analysis & Stability, Normal modes, Perturbation theory \\
Advanced & Central forces, Canonical transformations, Noether symmetry \\
Interactions & Collisions, Scattering, Variable mass \\
Continuum & Vibrating strings, Membranes, Fluid dynamics (SPH) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Code Generation Targets}

Table~\ref{tab:codegen} lists supported output formats.

\begin{table}[htbp]
\centering
\caption{Code generation targets and performance characteristics}
\label{tab:codegen}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Target} & \textbf{Use Case} & \textbf{Relative Speed} & \textbf{Dependencies} \\
\midrule
C++ (standard) & Production simulation & 1.0$\times$ (baseline) & g++/clang \\
C++ (OpenMP) & Parallel simulation & 4--8$\times$ & OpenMP \\
CUDA & GPU acceleration & 10--50$\times$ & NVIDIA GPU \\
Rust & Memory-safe systems & $\sim$1$\times$ & rustc \\
Julia & Scientific computing & $\sim$1$\times$ & Julia \\
Fortran & Legacy integration & $\sim$1$\times$ & gfortran \\
MATLAB/Octave & Education & 0.3--0.5$\times$ & MATLAB \\
JavaScript & Web visualization & 0.5--1$\times$ & Browser \\
WebAssembly & Browser (fast) & 0.8--1$\times$ & emscripten \\
Python & Rapid prototyping & 0.1$\times$ & NumPy \\
Arduino & Embedded systems & MCU-limited & Arduino \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Adaptive Solver Selection}

The simulator automatically selects integration methods:

\begin{itemize}
    \item \textbf{RK45}: Default for non-stiff systems with few degrees of freedom
    \item \textbf{LSODA}: Auto-switching for potentially stiff systems
    \item \textbf{Radau}: Implicit method for known stiff problems
\end{itemize}

Selection criteria include degrees of freedom ($n > 10 \Rightarrow$ LSODA), time span, and stiffness detection via trial integration.

%============================================================================
\section{Validation}
\label{sec:validation}
%============================================================================

We validate MechanicsDSL against analytical solutions and compare with existing tools.

\subsection{Analytical Benchmarks}

Table~\ref{tab:validation} summarizes validation tests.

\begin{table}[htbp]
\centering
\caption{Validation against analytical solutions}
\label{tab:validation}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{System} & \textbf{Test Metric} & \textbf{Expected} & \textbf{Achieved} \\
\midrule
Harmonic oscillator & Period accuracy & $T = 2\pi\sqrt{m/k}$ & $3.85 \times 10^{-11}$ error \\
Simple pendulum & Small-angle limit & $T = 2\pi\sqrt{l/g}$ & $< 10^{-8}$ error \\
Kepler problem & Orbital period & $T^2 \propto a^3$ & $< 10^{-6}$ error \\
Energy conservation & $\Delta E / E_0$ (100s) & 0 & $1.54 \times 10^{-7}$ \\
Angular momentum & $\Delta L / L_0$ & 0 & $< 10^{-12}$ \\
Figure-8 orbit & Periodicity return & $\mathbf{r}(T) = \mathbf{r}(0)$ & $6.3 \times 10^{-6}$ \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\textwidth]{fig2_energy_conservation.pdf}
\caption{Energy conservation for a simple pendulum over 50 seconds. Top: kinetic, potential, and total energy components. Bottom: relative energy error remains below $6 \times 10^{-8}$.}
\label{fig:energy}
\end{figure}

\subsection{Performance Benchmark}

We compare compilation time for equivalent simulations:

\begin{table}[htbp]
\centering
\caption{Development time comparison (double pendulum, 10s simulation)}
\label{tab:devtime}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Approach} & \textbf{Lines of Code} & \textbf{Dev Time} & \textbf{Run Time} \\
\midrule
MechanicsDSL & 15 & $<$1 min & 38.5 ms \\
SymPy + SciPy (manual) & 85 & 15--30 min & $\sim$50 ms \\
Pure NumPy (manual EOM) & 120 & 1--2 hours & $\sim$35 ms \\
\bottomrule
\end{tabular}
\end{table}

The DSL requires 5--10$\times$ fewer lines and 10--50$\times$ less development time while achieving comparable simulation performance.

\subsection{Code Generation Benchmark}

Table~\ref{tab:genbench} shows code generation performance.

\begin{table}[htbp]
\centering
\caption{Code generation performance (simple pendulum)}
\label{tab:genbench}
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Backend} & \textbf{Generation Time} & \textbf{Output Size} \\
\midrule
C++ & 1.4 ms & 2.1 KB \\
Python & 0.5 ms & 1.2 KB \\
Julia & 0.4 ms & 1.8 KB \\
Rust & 1.5 ms & 2.4 KB \\
CUDA & 5 ms & 8.2 KB \\
WebAssembly & 3 ms & 5.1 KB \\
\bottomrule
\end{tabular}
\end{table}

%============================================================================
\section{Usage Examples}
\label{sec:examples}
%============================================================================

\subsection{Chaotic Double Pendulum}

The double pendulum exhibits sensitive dependence on initial conditions:

\begin{lstlisting}
\system{double_pendulum}
\defvar{theta1}{Angle}{rad}
\defvar{theta2}{Angle}{rad}
\parameter{m1}{1.0}{kg}
\parameter{m2}{1.0}{kg}
\parameter{l1}{1.0}{m}
\parameter{l2}{1.0}{m}
\parameter{g}{9.81}{m/s^2}

\lagrangian{
  0.5*(m1+m2)*l1^2*\dot{theta1}^2
  + 0.5*m2*l2^2*\dot{theta2}^2
  + m2*l1*l2*\dot{theta1}*\dot{theta2}*cos(theta1-theta2)
  + (m1+m2)*g*l1*cos(theta1) + m2*g*l2*cos(theta2)
}
\end{lstlisting}

\subsection{Constrained System with Damping}

A pendulum with a sliding pivot demonstrates constraint handling:

\begin{lstlisting}
\system{sliding_pendulum}
\defvar{x}{Position}{m}
\defvar{theta}{Angle}{rad}
\parameter{M}{2.0}{kg}
\parameter{m}{1.0}{kg}
\parameter{l}{1.0}{m}
\parameter{g}{9.81}{m/s^2}
\parameter{b}{0.1}{N*s/m}

\lagrangian{
  0.5*M*\dot{x}^2 + 0.5*m*((\dot{x}+l*\dot{theta}*cos(theta))^2 
  + (l*\dot{theta}*sin(theta))^2) + m*g*l*cos(theta)
}

\rayleigh{0.5*b*\dot{x}^2}  % Damping on slider
\end{lstlisting}

\subsection{N-Body Gravitational System}

The three-body problem with the Figure-8 solution:

\begin{lstlisting}
\system{figure8}
\defvar{x1}{Position}{m}  \defvar{y1}{Position}{m}
\defvar{x2}{Position}{m}  \defvar{y2}{Position}{m}
\defvar{x3}{Position}{m}  \defvar{y3}{Position}{m}
\parameter{m}{1.0}{kg}
\parameter{G}{1.0}{1}

\lagrangian{
  0.5*m*(\dot{x1}^2 + \dot{y1}^2 + \dot{x2}^2 + \dot{y2}^2 
       + \dot{x3}^2 + \dot{y3}^2)
  + G*m^2/sqrt((x1-x2)^2 + (y1-y2)^2)
  + G*m^2/sqrt((x2-x3)^2 + (y2-y3)^2)
  + G*m^2/sqrt((x1-x3)^2 + (y1-y3)^2)
}
\end{lstlisting}

%============================================================================
\section{Conclusion}
\label{sec:conclusion}
%============================================================================

We have presented MechanicsDSL, a domain-specific language and compiler framework for classical mechanics simulation. The key contributions are:

\begin{enumerate}
    \item A formal algebraic characterization of physics DSL compilation
    \item A robust algorithm for symbolic equation solving
    \item A comprehensive implementation covering 17 physics domains
    \item Validation demonstrating accuracy and efficiency
\end{enumerate}

The framework bridges the gap between analytical mechanics formalism and numerical computation, making physics simulation accessible without programming expertise.

\subsection{Availability}

% URLs anonymized for double-blind review
\begin{itemize}
    \item \textbf{Repository}: [URL removed for review]
    \item \textbf{Package}: [Package name removed for review]
    \item \textbf{Documentation}: [URL removed for review]
    \item \textbf{License}: MIT
\end{itemize}

%============================================================================
% Acknowledgements
%============================================================================
\section*{Acknowledgements}

% Acknowledgements removed for double-blind review

%============================================================================
% References
%============================================================================
\begin{thebibliography}{99}

\bibitem{modelica}
P. Fritzson, \textit{Principles of Object-Oriented Modeling and Simulation with Modelica 3.3}, Wiley-IEEE Press, 2014.

\bibitem{sympy}
A. Meurer, et al., SymPy: symbolic computing in Python, \textit{PeerJ Computer Science} 3 (2017) e103.

\bibitem{fenics}
A. Logg, K.-A. Mardal, G. Wells (Eds.), \textit{Automated Solution of Differential Equations by the Finite Element Method}, Springer, 2012.

\bibitem{drake}
R. Tedrake, Drake: Planning, control, and analysis toolbox, \url{https://drake.mit.edu}, 2019.

\bibitem{scipy}
P. Virtanen, et al., SciPy 1.0: fundamental algorithms for scientific computing in Python, \textit{Nature Methods} 17 (2020) 261--272.

\bibitem{numpy}
C.R. Harris, et al., Array programming with NumPy, \textit{Nature} 585 (2020) 357--362.

\bibitem{goldstein}
H. Goldstein, C. Poole, J. Safko, \textit{Classical Mechanics}, 3rd ed., Addison Wesley, 2002.

\bibitem{lsoda}
L. Petzold, Automatic selection of methods for solving stiff and nonstiff systems of ordinary differential equations, \textit{SIAM J. Sci. Stat. Comput.} 4 (1983) 136--148.

\end{thebibliography}

\end{document}
